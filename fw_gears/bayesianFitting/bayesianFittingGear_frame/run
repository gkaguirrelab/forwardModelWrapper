#!/usr/bin/python3

import os
import json

# Flywheel path
flywheel_base ='/flywheel/v0/'
mcr_path = '/usr/local/MATLAB/MATLAB_Runtime/v97' #path to MATLAB runtime
matlab_func = '/opt/plot_func/renderInferredMaps.sh'

# Path to input folder 
native_mgz_maps_folder = os.path.join(flywheel_base, 'input', 'NativeMgzMaps')
struct_zip_folder = os.path.join(flywheel_base, 'input', 'structZipPath')

# Set path to required inputs
native_mgz_maps_zip_path = os.path.join(native_mgz_maps_folder, os.listdir(native_mgz_maps_folder)[0])
struct_zip_path = os.path.join(struct_zip_folder, os.listdir(struct_zip_folder)[0])

# Set other paths
manifest_file = os.path.join(flywheel_base, 'manifest.json')
config_path = os.path.join(flywheel_base, 'config.json')
first_output_dir = os.path.join('/opt', 'firstOutput')
final_output_dir = os.path.join(flywheel_base, 'output')

os.system('mkdir %s'%first_output_dir)

################### Unzip and set more paths ##################################

unzipped_maps = os.path.join('/opt' , 'unzipped_maps')
if not os.path.exists(unzipped_maps):
    os.system('mkdir %s'%unzipped_maps)
unzipped_hcp = os.path.join('/opt', 'unzipped_hcp')
if not os.path.exists(unzipped_hcp):
    os.system('mkdir %s'%unzipped_hcp)

os.system('unzip -q %s -d %s'%(native_mgz_maps_zip_path, unzipped_maps))
os.system('unzip -q %s -d %s'%(struct_zip_path, unzipped_hcp))
unzipped_map_folder = os.path.join(unzipped_maps, os.listdir(unzipped_maps)[0])
unzipped_map_folder = os.path.join(unzipped_maps, os.listdir(unzipped_maps)[0], os.listdir(unzipped_map_folder)[0])
subject_name = os.listdir(unzipped_hcp)[0]
unzipped_hcp_folder = os.path.join(unzipped_hcp, subject_name)

###################Parse Config Here############################
with open(config_path) as config_file:
    job_config = json.load(config_file)
config = job_config['config']

verbose = config['verbose']
no_volume_export = config['no-volume-export']
no_surface_export = config['no-surface-export']
no_registration_export = config['no-registration-export']
clean = config['clean']
partial_correction = config['partial-correction']
model_sym = config['model-sym']
weight_minimum = config['weight-min']
scale = config['scale']
field_sign_weight = config['field-sign-weight']
radius_weight = config['radius-weight']
maximum_steps = config['max-steps']
maximum_step_size = config['max-step-size']
prior = config['prior']
maximum_eccen = config['max-input-eccen']
minimum_eccen = config['min-input-eccen']

if 'pseudoHemisphere' in native_mgz_maps_zip_path:
    lh_angle = os.path.join(unzipped_map_folder, 'L_processed_angle_map.mgz')
    rh_angle = os.path.join(unzipped_map_folder, 'R_processed_angle_map.mgz')
    lh_eccen = os.path.join(unzipped_map_folder, 'L_processed_eccentricity_map.mgz')
    rh_eccen = os.path.join(unzipped_map_folder, 'R_processed_eccentricity_map.mgz')
    lh_radius = os.path.join(unzipped_map_folder, 'L_processed_rfsize_map.mgz')
    rh_radius = os.path.join(unzipped_map_folder, 'R_processed_rfsize_map.mgz')
    lh_weight = os.path.join(unzipped_map_folder, 'L_processed_R2_map.mgz')
    rh_weight = os.path.join(unzipped_map_folder, 'R_processed_R2_map.mgz')
else:
    lh_angle = os.path.join(unzipped_map_folder, 'L_original_angle_map.mgz')
    rh_angle = os.path.join(unzipped_map_folder, 'R_original_angle_map.mgz')
    lh_eccen = os.path.join(unzipped_map_folder, 'L_original_eccentricity_map.mgz')
    rh_eccen = os.path.join(unzipped_map_folder, 'R_original_eccentricity_map.mgz')
    lh_radius = os.path.join(unzipped_map_folder, 'L_original_rfsize_map.mgz')
    rh_radius = os.path.join(unzipped_map_folder, 'R_original_rfsize_map.mgz')
    lh_weight = os.path.join(unzipped_map_folder, 'L_original_R2_map.mgz')
    rh_weight = os.path.join(unzipped_map_folder, 'R_original_R2_map.mgz')

###################Run Algorithm################################

cmd = '''python3 -m neuropythy register_retinotopy %s \
--surf-outdir=%s --vol-outdir=%s --surf-format=mgz --weight-min=%s --scale=%s \
--field-sign-weight=%s --radius-weight=%s --max-steps=%s --max-step-size=%s \
--prior=%s --max-input-eccen=%s --min-input-eccen=%s \
--lh-angle=%s --rh-angle=%s \
--lh-eccen=%s --rh-eccen=%s \
--lh-radius=%s --rh-radius=%s \
--lh-weight=%s --rh-weight=%s'''%(unzipped_hcp_folder, first_output_dir,
first_output_dir, weight_minimum, scale, field_sign_weight, radius_weight,
maximum_steps, maximum_step_size, prior, maximum_eccen,minimum_eccen, lh_angle, rh_angle, lh_eccen, rh_eccen,
lh_radius, rh_radius, lh_weight, rh_weight)

if verbose == True:
    cmd = cmd + ' --verbose'
if no_volume_export == True:
    cmd + ' --no-volume-export'
if no_surface_export == True:
    cmd + ' --no-surface-export'
if no_registration_export == True:
    cmd + ' --no-registration-export'
if clean == True:
    cmd + ' --clean'
if partial_correction == True:
    cmd + ' --partial-correction'
if model_sym == True:
    cmd + ' --model-sym'

print(cmd)

os.system(cmd)

################## Run renderInferred #########################################

cmd = '%s %s %s %s %s'%(matlab_func, mcr_path, first_output_dir,
                        os.path.join(unzipped_hcp_folder, 'T1w', subject_name, 'surf'),
                        final_output_dir)
os.system(cmd)

################## Zip everything and output ##################################

os.system('cd %s; zip -r %s *'%(first_output_dir, os.path.join(final_output_dir,'inferences.zip')))