#!/usr/bin/python

import os
os.system("mv /opt/mcr/v95/bin/glnxa64/libexpat.so.1 /opt/mcr/v95/bin/glnxa64/libexpat.so.1-appended")
import json
import neuropythy as ny
import numpy as np

compiled_name = next(os.walk('/opt/func_input/'))[1][0]

flywheel_base ='/flywheel/v0/'
data_main_path = flywheel_base + 'input/' + 'DataFile'  
hcp_main_path = flywheel_base + 'input/' + 'HCPstruct'
manifest_file = flywheel_base + 'manifest.json'
config_path = flywheel_base + 'config.json'
stimulus_input_dir = flywheel_base + 'input/' + 'StimulusFile' 
hrf_input_dir = flywheel_base + 'input/' + 'HRF' 
mask_input_dir = flywheel_base + 'input/' + 'MaskFileName' 
matlab_func = '/opt/func_input/%s/for_testing/run_%s.sh'%(compiled_name, compiled_name) #compiled matlab function to run
output_dir = flywheel_base + 'output/'  #Added slash for this gear
first_level_output_dir = '/opt/first_level_output/' #Added slash for this gear
mcr_path = '/opt/mcr/v95' #path to MATLAB runtime
workbench_path = '/opt/workbench/bin_linux64/wb_command'

################Check input directory and set some paths #########

data_input_dir = '/opt/data'  
os.system('mkdir %s'%(data_input_dir)) 
hcp_input_dir  = '/opt/hcp'
os.system('mkdir %s'%(hcp_input_dir)) 

if len(os.listdir(data_main_path)) == 0:
    print("Data directory is empty")
if len(os.listdir(stimulus_input_dir)) == 0:
    print("Stimulus directory is empty")
else:
    os.system("unzip %s/*.zip -d %s"%(data_main_path, data_input_dir))
    if os.path.isdir(hcp_main_path) == True:
        os.system("unzip %s/*.zip -d %s"%(hcp_main_path, hcp_input_dir))
        path_to_subject = hcp_input_dir + '/' + os.listdir(hcp_input_dir)[0]

    stimulus_path = stimulus_input_dir + '/' + os.listdir(stimulus_input_dir)[0]   #This is the stimulus folder
    data_path = data_input_dir + '/' + os.listdir(data_input_dir)[0]

    if os.path.isdir(mask_input_dir) == False:
        mask_path = 'Na'
    else:
        mask_path = mask_input_dir + '/' + os.listdir(mask_input_dir)[0]

    if os.path.isdir(hrf_input_dir) == False:
        hrf_path = 'Na'
    else:
        hrf_path = hrf_input_dir + '/' + os.listdir(hrf_input_dir)[0]

        

###################Parse Config Here############################

with open(config_path) as config_file:
    job_config = json.load(config_file)
config = job_config['config']

dataFileType = config['dataFileType']
tr = config['TR']
prependDummyTRs = config['prependDummyTRs']
thresholdData = config['thresholdData']
pixelToDegree = config['pixelToDegree']
wantglmdenoise = config['wantglmdenoise']
maxpolydeg = config['maxpolydeg']
seedmode = config['seedmode']
xvalmode = config['xvalmode']
numperjob = config['numperjob']
maxiter = config['maxiter']
display = config['display']
typicalgain = config['typicalgain']


###################Run Algorithm################################
    
# outputpath = output_dir + '/' + input_file_name + '_output' ###
cmd = '%s %s %s %s %s %s %s %scifti_maps/ maskFileName %s hrf %s prependDummyTRs %s thresholdData %s pixelToDegree %s wantglmdenoise %s maxpolydeg %s seedmode "%s" xvalmode %s numperjob %s maxiter %s display %s typicalgain %s'%(matlab_func, mcr_path, workbench_path, stimulus_path, data_input_dir, dataFileType, tr, first_level_output_dir, mask_path, hrf_path, prependDummyTRs, thresholdData, pixelToDegree, wantglmdenoise, maxpolydeg, seedmode, xvalmode, numperjob, maxiter, display, typicalgain)
os.system(cmd)
    
###################### This is run if HCP set #################################
if os.path.isdir(hcp_main_path) == True:
    
    path_to_cifti_maps = first_level_output_dir + 'cifti_maps/'
    output = '/opt/first_level_output/mgz_maps/'
    
############# Load the FSLR_32k and native left and right hemispheres #########
    
    sub = ny.hcp_subject(path_to_subject, default_alignment='FS')
    #sub = ny.hcp_subject(path_to_subject, default_alignment='MSMSulc')
    hem_from_left = sub.hemis['lh_LR32k']
    hem_to_left = sub.hemis['lh']
    hem_from_right = sub.hemis['rh_LR32k']
    hem_to_right = sub.hemis['rh']
    
############# Set a dictionary for the AnalyzePRF results #####################
    
    maps = {}
    maps['angle_map'] = "%sangle_map.dtseries.nii"%path_to_cifti_maps
    maps['eccentricity_map'] = "%seccentricity_map.dtseries.nii"%path_to_cifti_maps
    maps['exponent_map'] = "%sexponent_map.dtseries.nii"%path_to_cifti_maps
    maps['gain_map'] = "%sgain_map.dtseries.nii"%path_to_cifti_maps
    maps['R2_map'] = "%sR2_map.dtseries.nii"%path_to_cifti_maps
    maps['rfsize_map'] = "%srfsize_map.dtseries.nii"%path_to_cifti_maps
    maps['x_map'] = "%sx_map.dtseries.nii"%path_to_cifti_maps
    maps['y_map'] = "%sy_map.dtseries.nii"%path_to_cifti_maps
    
############ Interpolate AnalyzePRF maps over subject's native surface ########
    
    for i in maps.keys():
        im = ny.load(maps[i])
        (lhdat, rhdat, other) = ny.hcp.cifti_split(im)   # Separate left and right hemispheres
        native_result_left = hem_from_left.interpolate(hem_to_left, lhdat)
        native_result_right = hem_from_right.interpolate(hem_to_right, rhdat)
        ny.save("%sL_%s.mgz"%(output,i), native_result_left)
        ny.save("%sR_%s.mgz"%(output,i), native_result_right)    
    
##################### Convert cartesian x-y maps to polar maps ################    
    
    path_to_left_x_mgz = output + 'L_x_map.mgz'
    path_to_right_x_mgz = output + 'R_x_map.mgz'
    path_to_left_y_mgz = output + 'L_y_map.mgz'
    path_to_right_y_mgz = output + 'R_y_map.mgz'
    
    left_x = ny.load(path_to_left_x_mgz)
    left_y = ny.load(path_to_left_y_mgz)
    right_x = ny.load(path_to_right_x_mgz)
    right_y = ny.load(path_to_right_y_mgz)
    
    left_angle_new_template = np.rad2deg(np.mod(np.arctan2(left_y,left_x), 2*np.pi))
    left_eccentricity_new_template = np.sqrt(left_x**2 + left_y**2)
    right_angle_new_template = np.rad2deg(np.mod(np.arctan2(right_y,right_x), 2*np.pi))
    right_eccentricity_new_template = np.sqrt(right_x**2 + right_y**2)
    
###################### Wrap angle maps to -180 - 180 scale ####################

    left_angle_converted = (np.abs(left_angle_new_template - 360) + 90) % 360
    for i in range(len(left_angle_new_template)):
        if left_angle_converted[i] < -180 or left_angle_converted[i] > 180:
            left_angle_converted[i] = ((left_angle_converted[i] + 180) % 360) - 180
    
    right_angle_converted = (np.abs(right_angle_new_template - 360) + 90) % 360
    for i in range(len(right_angle_new_template)):
        if right_angle_converted[i] < -180 or right_angle_converted[i] > 180:
            right_angle_converted[i] = ((right_angle_converted[i] + 180) % 360) - 180

############################### Save results ##################################

    ny.save("%sL_new_angle.mgz"%output, left_angle_new_template)  
    ny.save("%sL_new_eccen.mgz"%output, left_eccentricity_new_template)
    ny.save("%sR_new_angle.mgz"%output, right_angle_new_template)  
    ny.save("%sR_new_eccen.mgz"%output, right_eccentricity_new_template)  
    ny.save("%sL_new_angle_converted.mgz"%output, left_angle_converted)
    ny.save("%sR_new_angle_converted.mgz"%output, right_angle_converted)
    
################## Zip everything and output ##################################
    
os.system("zip %scifti_maps.zip %s"%(output_dir, first_level_output_dir + 'cifti_maps' ))
if os.path.isdir(hcp_main_path) == True:
    os.system("zip %smgz_maps.zip %s"%(output_dir, first_level_output_dir + 'mgz_maps' ))

